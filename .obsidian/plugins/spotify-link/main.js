/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SpotifyLinkPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/api.ts
var import_obsidian = require("obsidian");

// src/utils.ts
function prepareData(data) {
  return Object.keys(data).map((key) => encodeURIComponent(key) + "=" + encodeURIComponent(data[key])).join("&");
}
function millisToMinutesAndSeconds(millis) {
  const minutes = Math.floor(millis / 6e4);
  const seconds = parseInt((millis % 6e4 / 1e3).toFixed(0));
  if (minutes === 0) {
    return (seconds < 10 ? "0" : "") + seconds + "s";
  }
  return minutes + "m:" + (seconds < 10 ? "0" : "") + seconds + "s";
}
function millisToSeconds(millis) {
  return (millis / 1e3).toFixed(0);
}
function isPath(str) {
  const pathRegex = /^[a-zA-Z0-9_\\/.]+$/;
  return Boolean(str.match(pathRegex));
}
function padZero(date) {
  return ("0" + date).slice(-2);
}

// src/episode.ts
function isEpisode(data) {
  return data.item.type === "episode";
}
function getEpisodeMessageTimestamp(data) {
  if (!isEpisode(data))
    throw new Error("Not an episode.");
  const episode = data.item;
  const episode_name = episode == null ? void 0 : episode.name;
  const description = episode == null ? void 0 : episode.description;
  const release_date = episode == null ? void 0 : episode.release_date;
  const progress = data.progress_ms;
  const duration = episode.duration_ms;
  const url = episode.external_urls.spotify;
  return `['**${episode_name}**': ***${description}***, released ${release_date} | **${millisToMinutesAndSeconds(
    progress
  )}** (${(progress / duration * 100).toFixed(0)}%)](${url})`;
}
function getEpisodeMessage(data, template) {
  var _a, _b, _c, _d, _e;
  if (!isEpisode(data))
    throw new Error("Not an episode.");
  const episode = data.item;
  const progressInMilliseconds = data.progress_ms.toFixed(0);
  const progressInSeconds = millisToSeconds(data.progress_ms);
  const progressInMinutesAndSeconds = millisToMinutesAndSeconds(
    data.progress_ms
  );
  return template.replace(/{{ episode_name }}|{{episode_name}}/g, episode.name).replace(
    /{{ episode_link }}|{{episode_link}}/g,
    `[${episode.name}](${episode.external_urls.spotify})`
  ).replace(
    /{{ description }}|{{description}}|{{ description\[(\d+)\] }}|{{description\[(\d+)\]}}/g,
    (_, len) => {
      let parsed_len = len;
      if (parseInt(len) > episode.description.length || isNaN(len))
        parsed_len = episode.description.length;
      return `${episode.description.slice(0, parsed_len)}${episode.description.length != parsed_len ? "..." : ""}`;
    }
  ).replace(
    /{{ duration_ms }}|{{duration_ms}}/g,
    episode.duration_ms.toString()
  ).replace(
    /{{ audio_preview_url }}|{{audio_preview_url}}/g,
    `![Audio preview url](${episode.audio_preview_url})`
  ).replace(
    /{{ episode_cover_large }}|{{episode_cover_large}}/g,
    `![${episode.name}](${(_a = episode.images[0]) == null ? void 0 : _a.url})`
  ).replace(
    /{{ episode_cover_medium }}|{{episode_cover_medium}}/g,
    `![${episode.name}](${(_b = episode.images[1]) == null ? void 0 : _b.url})`
  ).replace(
    /{{ episode_cover_small }}|{{episode_cover_small}}/g,
    `![${episode.name}](${(_c = episode.images[2]) == null ? void 0 : _c.url})`
  ).replace(
    /{{ episode_cover_link_large }}|{{episode_cover_link_large}}/g,
    `[Cover - ${episode.name}](${episode.images[0].url})`
  ).replace(
    /{{ episode_cover_link_medium }}|{{episode_cover_link_medium}}/g,
    `[Cover - ${episode.name}](${(_d = episode.images[1]) == null ? void 0 : _d.url})`
  ).replace(
    /{{ episode_cover_link_small }}|{{episode_cover_link_small}}/g,
    `[Cover - ${episode.name}](${(_e = episode.images[2]) == null ? void 0 : _e.url})`
  ).replace(/{{ release_date }}|{{release_date}}/g, episode.release_date).replace(/{{ show_name }}|{{show_name}}/g, episode.show.name).replace(/{{ publisher }}|{{publisher}}/g, episode.show.publisher).replace(
    /{{ show_description }}|{{show_description}}/g,
    episode.show.description
  ).replace(
    /{{ show_link }}|{{show_link}}/g,
    episode.show.external_urls.spotify
  ).replace(
    /{{ total_episodes }}|{{total_episodes}}/g,
    episode.show.total_episodes.toString()
  ).replace(/{{ progress_ms }}|{{progress_ms}}/g, progressInMilliseconds).replace(/{{ progress_sec }}|{{progress_sec}}/g, progressInSeconds).replace(
    /{{ progress_min_sec }}|{{progress_min_sec}}/g,
    progressInMinutesAndSeconds
  ).replace(
    /{{ timestamp(z?)(\(((YYYY-MM-DD)?( ?HH:mm)?)\))? }}|{{timestamp(z?)(\(((YYYY-MM-DD)?( ?HH:mm)?)\))?}}/g,
    (_match, ...options) => {
      const matches = options.slice(0, options.length - 2).filter((m) => m !== void 0);
      let timestamp = "";
      const hasYearMonthDate = matches.includes("YYYY-MM-DD");
      const hasHourMinutes = matches.includes(" HH:mm") || matches.includes("HH:mm");
      if (matches.includes("z")) {
        if (hasYearMonthDate) {
          timestamp += `${new Date().getUTCFullYear()}-${padZero(new Date().getUTCMonth() + 1)}-${padZero(new Date().getUTCDate())}`;
        }
        if (hasHourMinutes) {
          if (timestamp.length > 0) {
            timestamp += " ";
          }
          timestamp += `${padZero(new Date().getUTCHours())}:${padZero(new Date().getUTCMinutes())}`;
        }
        if (matches.length === 1) {
          timestamp = `${new Date().toISOString()}`;
        }
      } else {
        if (hasYearMonthDate) {
          timestamp += `${new Date().getFullYear()}-${padZero(new Date().getMonth() + 1)}-${padZero(new Date().getDate())}`;
        }
        if (hasHourMinutes) {
          if (timestamp.length > 0) {
            timestamp += " ";
          }
          timestamp += `${padZero(new Date().getHours())}:${padZero(new Date().getMinutes())}`;
        }
        if (matches.length === 1) {
          timestamp = `${new Date().toDateString()} - ${new Date().toLocaleTimeString()}`;
        }
      }
      return timestamp;
    }
  );
}

// src/track.ts
function getTrackType(data) {
  return data.currently_playing_type;
}
function isTrack(data) {
  return data.item.type === "track";
}
function getTrackMessageTimestamp(data) {
  if (!isTrack(data))
    throw new Error("Not a track.");
  const track = data.item;
  const song_name = (track == null ? void 0 : track.name) || "Error: Song name unavailable";
  const artists = (track == null ? void 0 : track.artists) || [];
  const progress = data.progress_ms;
  const duration = parseInt(track.duration_ms);
  const url = track.external_urls.spotify;
  return `['**${song_name}**' by ***${artists.map((a) => (a == null ? void 0 : a.name) || "Unknown").join(", ")}*** **${millisToMinutesAndSeconds(progress)}** (${(progress / duration * 100).toFixed(0)}%)](${url})`;
}
function getTrackMessage(data, artists, template) {
  var _a, _b, _c, _d;
  if (!isTrack(data))
    throw new Error("Not a track.");
  const track = data.item;
  return template.replace(/{{ song_name }}|{{song_name}}/g, track.name).replace(
    /{{ song_link }}|{{song_link}}/g,
    `[${track.name} - ${track.artists.map((a) => a.name).join(", ")}](${track.external_urls.spotify})`
  ).replace(
    /{{ artists }}|{{artist}}/g,
    track.artists.map((a) => a.name).join(", ")
  ).replace(
    /{{ artists_formatted(:.*?)?(:.*?)? }}|{{artists_formatted(:.*?)?(:.*?)?}}/g,
    (_match, ...options) => {
      var _a2, _b2;
      const matches = options.slice(0, options.length - 2).filter((m) => m !== void 0);
      const prefix = ((_a2 = matches[0]) == null ? void 0 : _a2.substring(1)) || "";
      const suffix = ((_b2 = matches[1]) == null ? void 0 : _b2.substring(1)) || "";
      const isTag = prefix === "#";
      if (isTag) {
        return track.artists.map(
          (a) => {
            var _a3;
            return `${prefix}${(_a3 = a.name) == null ? void 0 : _a3.replace(/ /g, "_")}${suffix}`;
          }
        ).join("\n");
      }
      return track.artists.map((a) => `${prefix}${a.name}${suffix}`).join("\n");
    }
  ).replace(
    /{{ album_release }}|{{album_release}}/g,
    track.album.release_date
  ).replace(
    /{{ album_cover_large }}|{{album_cover_large}}/g,
    `![${track.album.name}](${track.album.images[0].url})`
  ).replace(
    /{{ album_cover_medium }}|{{album_cover_medium}}/g,
    `![${track.album.name}](${(_a = track.album.images[1]) == null ? void 0 : _a.url})`
  ).replace(
    /{{ album_cover_small }}|{{album_cover_small}}/g,
    `![${track.album.name}](${(_b = track.album.images[2]) == null ? void 0 : _b.url})`
  ).replace(
    /{{ album_cover_link_large }}|{{album_cover_link_large}}/g,
    `[Cover - ${track.album.name}](${track.album.images[0].url})`
  ).replace(
    /{{ album_cover_link_medium }}|{{album_cover_link_medium}}/g,
    `[Cover - ${track.album.name}](${(_c = track.album.images[1]) == null ? void 0 : _c.url})`
  ).replace(
    /{{ album_cover_link_small }}|{{album_cover_link_small}}/g,
    `[Cover - ${track.album.name}](${(_d = track.album.images[2]) == null ? void 0 : _d.url})`
  ).replace(
    /{{ album_link }}|{{album_link}}/g,
    `[${track.album.name}](${track.album.external_urls.spotify})`
  ).replace(/{{ album }}|{{album}}/g, track.album.name).replace(
    /{{ timestamp(z?)(\(((YYYY-MM-DD)?( ?HH:mm)?)\))? }}|{{timestamp(z?)(\(((YYYY-MM-DD)?( ?HH:mm)?)\))? }}/g,
    (_match, ...options) => {
      const matches = options.slice(0, options.length - 2).filter((m) => m !== void 0);
      let timestamp = "";
      const hasYearMonthDate = matches.includes("YYYY-MM-DD");
      const hasHourMinutes = matches.includes(" HH:mm") || matches.includes("HH:mm");
      if (matches.includes("z")) {
        if (hasYearMonthDate) {
          timestamp += `${new Date().getUTCFullYear()}-${padZero(new Date().getUTCMonth() + 1)}-${padZero(new Date().getUTCDate())}`;
        }
        if (hasHourMinutes) {
          if (timestamp.length > 0) {
            timestamp += " ";
          }
          timestamp += `${padZero(new Date().getUTCHours())}:${padZero(new Date().getUTCMinutes())}`;
        }
        if (matches.length === 1) {
          timestamp = `${new Date().toISOString()}`;
        }
      } else {
        if (hasYearMonthDate) {
          timestamp += `${new Date().getFullYear()}-${padZero(new Date().getMonth() + 1)}-${padZero(new Date().getDate())}`;
        }
        if (hasHourMinutes) {
          if (timestamp.length > 0) {
            timestamp += " ";
          }
          timestamp += `${padZero(new Date().getHours())}:${padZero(new Date().getMinutes())}`;
        }
        if (matches.length === 1) {
          timestamp = `${new Date().toDateString()} - ${new Date().toLocaleTimeString()}`;
        }
      }
      return timestamp;
    }
  ).replace(
    /{{ genres }}|{{genres}}/g,
    Array.from(new Set(artists == null ? void 0 : artists.map((artist) => artist.genres))).flat(Infinity).join(", ")
  ).replace(
    /{{ genres_array }}|{{genres_array}}/g,
    Array.from(
      new Set(
        artists == null ? void 0 : artists.map(
          (artist) => {
            var _a2;
            return (_a2 = artist.genres) == null ? void 0 : _a2.map((g) => `"${g}"`);
          }
        )
      )
    ).flat(Infinity).join(", ")
  ).replace(
    /{{ genres_hashtag }}|{{genres_hashtag}}/g,
    Array.from(
      new Set(
        artists == null ? void 0 : artists.map(
          (artist) => {
            var _a2;
            return (_a2 = artist.genres) == null ? void 0 : _a2.map((g) => `#${g.replace(/ /g, "_")}`);
          }
        )
      )
    ).flat(Infinity).join(" ")
  ).replace(
    /{{ followers }}|{{followers}}/g,
    artists.length > 1 ? artists == null ? void 0 : artists.map(
      (artist) => `${artist.name}: ${artist.followers.total}`
    ).join(", ") : artists[0].followers.total.toString()
  ).replace(
    /{{ popularity }}|{{popularity}}/g,
    artists.length > 1 ? artists == null ? void 0 : artists.map(
      (artist) => `${artist.name}: ${artist.popularity}`
    ).join(", ") : artists[0].popularity.toString()
  ).replace(
    /{{ artist_image }}|{{artist_image}}/g,
    artists == null ? void 0 : artists.map((artist) => `![${artist.name}](${artist.images[0].url})`).join(", ")
  ).replace(
    /{{ artist_name }}|{{artist_name}}/g,
    artists == null ? void 0 : artists.map((artist) => artist.name).join(", ")
  );
}

// src/output.ts
function processCurrentlyPlayingTrackInput(data) {
  if (data && data.is_playing) {
    if (getTrackType(data) === "track") {
      return getTrackMessageTimestamp(data);
    }
    if (getTrackType(data) === "episode") {
      return getEpisodeMessageTimestamp(data);
    }
    throw new Error(
      "The data received is not handle. You can request it by opening a GitHub issue and providing the track URL so that I can adjust the tool accordingly."
    );
  }
  return "No song is playing.";
}
async function processCurrentlyPlayingTrack(clientId, clientSecret, data, template = `'{{ song_name }}' by {{ artists }} from {{ album }} released in {{ album_release }}
{{ timestamp }}`) {
  if (data && data.is_playing) {
    if (getTrackType(data) === "track") {
      const artists = data.item.artists.map(
        (artist) => getArtist(clientId, clientSecret, artist.id)
      );
      return getTrackMessage(data, await Promise.all(artists), template);
    }
    if (getTrackType(data) === "episode") {
      return getEpisodeMessage(data, template);
    }
    throw new Error(
      "The data received is not handle. You can request it by opening a GitHub issue and providing the track URL so that I can adjust the tool accordingly."
    );
  }
  return "No song is playing.";
}

// src/api.ts
var SPOTIFY_API_BASE_ADDRESS = "https://api.spotify.com/v1";
var REDIRECT_URI = "obsidian://spotify-auth/";
function generateLoginUrl(clientId, state, scope, redirectUri) {
  const q = `response_type=code&client_id=${clientId}&scope=${scope}&redirect_uri=${redirectUri}&state=${state}`;
  return `https://accounts.spotify.com/authorize?${q}`;
}
async function handleCallback(params, clientId, clientSecret, state) {
  if (params.state !== state)
    throw new Error("Invalid state");
  if (params.error)
    throw new Error(params.error);
  if (!params.code)
    throw new Error("Missing Code");
  const response = await requestAccessToken(
    clientId,
    clientSecret,
    params.code,
    REDIRECT_URI
  );
  setAccessToken(response.access_token);
  setRefreshToken(response.refresh_token);
  setExpiration(response.expires_in);
  return true;
}
async function requestAccessToken(clientId, clientSecret, code, redirect_uri) {
  const data = {
    code,
    redirect_uri,
    grant_type: "authorization_code"
  };
  return await (0, import_obsidian.requestUrl)({
    url: "https://accounts.spotify.com/api/token",
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      Authorization: `Basic ${btoa(clientId + ":" + clientSecret)}`
    },
    body: prepareData(data)
  }).then((res) => res.json);
}
function setAccessToken(accessToken) {
  window.localStorage.setItem("access_token", accessToken);
}
function setRefreshToken(refreshToken) {
  window.localStorage.setItem("refresh_token", refreshToken);
}
function setExpiration(expiresIn) {
  window.localStorage.setItem(
    "expires_in",
    (new Date().getTime() + expiresIn * 1e3).toString()
  );
}
async function requestRefreshToken(clientId, clientSecret) {
  const refreshToken = getRefreshToken();
  const data = {
    client_id: clientId,
    refresh_token: refreshToken,
    grant_type: "refresh_token"
  };
  const response = await (0, import_obsidian.requestUrl)({
    url: "https://accounts.spotify.com/api/token",
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      Authorization: `Basic ${btoa(clientId + ":" + clientSecret)}`
    },
    body: prepareData(data)
  }).then((res) => res.json);
  setAccessToken(response.access_token);
  setRefreshToken(response.refresh_token || refreshToken);
  setExpiration(response.expires_in);
  return response.access_token;
}
async function getCurrentlyPlayingTrack(clientId, clientSecret) {
  var _a;
  const token = await getAccessToken(clientId, clientSecret);
  try {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${SPOTIFY_API_BASE_ADDRESS}/me/player/currently-playing?additional_types=track,episode`,
      method: "GET",
      headers: {
        Authorization: `Bearer ${token}`
      }
    });
    const { json } = response;
    if (response.status !== 200) {
      throw new Error(((_a = json == null ? void 0 : json.error) == null ? void 0 : _a.message) || response.status);
    }
    const currentlyPlayingTrack = json;
    if (!currentlyPlayingTrack)
      throw new Error("Unable to get the currently playing track.");
    return currentlyPlayingTrack;
  } catch (e) {
    throw new Error("Unable to get the currently playing track.");
  }
}
async function getCurrentlyPlayingTrackAsString(clientId, clientSecret) {
  const track = await getCurrentlyPlayingTrack(clientId, clientSecret);
  return processCurrentlyPlayingTrackInput(track);
}
async function getMe(clientId, clientSecret) {
  var _a;
  const token = await getAccessToken(clientId, clientSecret);
  const response = await (0, import_obsidian.requestUrl)({
    url: `${SPOTIFY_API_BASE_ADDRESS}/me`,
    method: "GET",
    headers: {
      Authorization: `Bearer ${token}`
    }
  });
  const { json } = response;
  if (response.status !== 200) {
    throw new Error(((_a = json == null ? void 0 : json.error) == null ? void 0 : _a.message) || response.status);
  }
  return json;
}
async function getArtist(clientId, clientSecret, artistId) {
  var _a;
  const token = await getAccessToken(clientId, clientSecret);
  try {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${SPOTIFY_API_BASE_ADDRESS}/artists/${artistId}`,
      method: "GET",
      headers: {
        Authorization: `Bearer ${token}`
      }
    });
    const { json } = response;
    if (response.status !== 200) {
      throw new Error(((_a = json == null ? void 0 : json.error) == null ? void 0 : _a.message) || response.status);
    }
    const artist = json;
    if (!artist)
      throw new Error("Unable to get the artist.");
    return artist;
  } catch (e) {
    throw new Error("Unable to get the artist.");
  }
}
async function getSpotifyUrl(clientId, clientSecret) {
  const me = await getMe(clientId, clientSecret);
  return me.external_urls.spotify;
}
function getExpiration() {
  const expiration = window.localStorage.getItem("expires_in");
  if (!expiration)
    throw new Error(
      "Something went wrong, please manually log back to spotify."
    );
  return parseInt(expiration);
}
async function getAccessToken(clientId, clientSecret) {
  const token = window.localStorage.getItem("access_token");
  if (!token)
    throw new Error("You are not connected to Spotify.");
  if (new Date().getTime() <= getExpiration())
    return token;
  return await requestRefreshToken(clientId, clientSecret);
}
function getRefreshToken() {
  const token = window.localStorage.getItem("refresh_token");
  if (!token)
    throw new Error("You are not connected to Spotify.");
  return token;
}

// src/settingsTab.ts
var import_obsidian2 = require("obsidian");
var SettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const div = containerEl.createDiv();
    div.createEl("p", {
      text: "Follow the link below to get your Client Id and Client Secret, you need a spotify account to get access."
    });
    div.createEl("a", {
      href: "https://developer.spotify.com/dashboard/",
      text: "Spotify Developer"
    });
    div.createEl("ol").createEl("li", { text: "Create an App" }).createEl("li", { text: "Click Settings" }).createEl("li", { text: "Copy the Client Id and Secret" }).createEl("li", {
      text: "Set the Redirect URI to : obsidian://spotify-auth/"
    }).createEl("li", {
      text: "Select the Spotify icon located in Obsidian's left sidebar to connect."
    });
    div.createEl("p", {
      text: "NOTICE: The id and secret will be stored unencrypted on your local device. If you sync your data to a public source, the id and secret will be shown as-is."
    });
    new import_obsidian2.Setting(containerEl).setName("Spotify Client ID").setDesc("Client ID (Keep this secured)").addText((text) => {
      text.setPlaceholder("Enter your client id").setValue(this.plugin.settings.spotifyClientId).onChange(async (value) => {
        this.plugin.settings.spotifyClientId = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.setAttribute("type", "password");
    });
    new import_obsidian2.Setting(containerEl).setName("Spotify Client Secret").setDesc("Client Secret (Keep this secured)").addText((text) => {
      text.setPlaceholder("Enter your client Secret").setValue(this.plugin.settings.spotifyClientSecret).onChange(async (value) => {
        this.plugin.settings.spotifyClientSecret = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.setAttribute("type", "password");
    });
    new import_obsidian2.Setting(containerEl).setName("Spotify State").setDesc("State").addText((text) => {
      text.setPlaceholder("Enter your State").setValue(this.plugin.settings.spotifyState).onChange(async (value) => {
        this.plugin.settings.spotifyState = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.setAttribute("type", "password");
    });
    new import_obsidian2.Setting(containerEl).setName("Spotify Redirect URI").setDesc("Redirect URI (Read Only)").addText((text) => {
      text.setValue("obsidian://spotify-auth/").setDisabled(true);
    });
    containerEl.createEl("hr");
    containerEl.createEl("h5", { text: "Templates" });
    const divDoc = containerEl.createDiv();
    divDoc.createEl("h6", { text: "External resources" });
    const list = divDoc.createEl("ul");
    list.createEl("li").createEl("a", {
      href: "https://studiowebux.github.io/obsidian-plugins-docs/docs/spotify-link/custom-template",
      text: "Custom Template Documentation"
    });
    list.createEl("li").createEl("a", {
      href: "https://github.com/studiowebux/obsidian-spotify-link/blob/main/examples/",
      text: "Template Examples"
    });
    divDoc.createEl("p", { text: "Available variables (song):" });
    divDoc.createEl("ul").createEl("li", { text: "{{ album }}" }).createEl("li", { text: "{{ album_release }}" }).createEl("li", { text: "{{ album_cover_large }}" }).createEl("li", { text: "{{ album_cover_medium }}" }).createEl("li", { text: "{{ album_cover_small }}" }).createEl("li", { text: "{{ album_cover_link_large }}" }).createEl("li", { text: "{{ album_cover_link_medium }}" }).createEl("li", { text: "{{ album_cover_link_small }}" }).createEl("li", { text: "{{ album_link }}" }).createEl("li", { text: "{{ artists }}" }).createEl("li", { text: "{{ artists_formatted:PREFIX:SUFFIX }}" }).createEl("li", { text: "{{ song_name }}" }).createEl("li", { text: "{{ song_link }}" }).createEl("li", { text: "{{ timestampz }}" }).createEl("li", { text: "{{ timestamp(HH:mm) }}" }).createEl("li", { text: "{{ timestampz(HH:mm) }}" }).createEl("li", { text: "{{ timestamp(YYYY-MM-DD) }}" }).createEl("li", { text: "{{ timestampz(YYYY-MM-DD) }}" }).createEl("li", { text: "{{ timestamp(YYYY-MM-DD HH:mm) }}" }).createEl("li", { text: "{{ timestampz(YYYY-MM-DD HH:mm) }}" }).createEl("li", { text: "{{ genres }}" }).createEl("li", { text: "{{ genres_array }}" }).createEl("li", { text: "{{ genres_hashtag }}" }).createEl("li", { text: "{{ followers }}" }).createEl("li", { text: "{{ artist_image }}" }).createEl("li", { text: "{{ popularity }}" }).createEl("li", { text: "{{ artist_names }}" });
    divDoc.createEl("p", { text: "Available variables (podcast):" });
    divDoc.createEl("ul").createEl("li", { text: "{{ episode_name }}" }).createEl("li", { text: "{{ episode_link }}" }).createEl("li", { text: "{{ description }}" }).createEl("li", { text: "{{ duration_ms }}" }).createEl("li", { text: "{{ audio_preview_url }}" }).createEl("li", { text: "{{ episode_cover_large }}" }).createEl("li", { text: "{{ episode_cover_medium }}" }).createEl("li", { text: "{{ episode_cover_small }}" }).createEl("li", { text: "{{ episode_cover_link_large }}" }).createEl("li", { text: "{{ episode_cover_link_medium }}" }).createEl("li", { text: "{{ episode_cover_link_small }}" }).createEl("li", { text: "{{ release_date }}" }).createEl("li", { text: "{{ show_name }}" }).createEl("li", { text: "{{ publisher }}" }).createEl("li", { text: "{{ show_description }}" }).createEl("li", { text: "{{ show_link }}" }).createEl("li", { text: "{{ total_episodes }}" }).createEl("li", { text: "{{ progress_ms }}" }).createEl("li", { text: "{{ progress_sec }}" }).createEl("li", { text: "{{ progress_min_sec }}" }).createEl("li", { text: "{{ timestamp }}" }).createEl("li", { text: "{{ timestampz }}" }).createEl("li", { text: "{{ timestamp(HH:mm) }}" }).createEl("li", { text: "{{ timestampz(HH:mm) }}" }).createEl("li", { text: "{{ timestamp(YYYY-MM-DD) }}" }).createEl("li", { text: "{{ timestampz(YYYY-MM-DD) }}" }).createEl("li", { text: "{{ timestamp(YYYY-MM-DD HH:mm) }}" }).createEl("li", { text: "{{ timestampz(YYYY-MM-DD HH:mm) }}" });
    divDoc.createEl("p", { text: "Template Selection:" });
    divDoc.createEl("p", {
      text: "You have two options to specify a template: 'Inline' or 'Path-based'."
    });
    divDoc.createEl("ul").createEl("li", {
      text: "To use the inline method, simply include your template directly."
    }).createEl("li", {
      text: "For path-based selection, you must reference the Vault. A valid example would be: 'Templates/Spotify/track.md' and the content structure is exactly the same as the inline template."
    });
    new import_obsidian2.Setting(containerEl).setName("Template for song").setDesc(
      "Define a custom template to print the currently playing song (Song only) or a path to your template definition"
    ).addTextArea(
      (text) => text.setPlaceholder(
        "Example: '{{ song_name }}' by {{ artists }} from {{ album }} released in {{ album_release }}\n{{ timestamp }}"
      ).setValue(this.plugin.settings.templates[0]).onChange(async (value) => {
        this.plugin.settings.templates[0] = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Template for podcast").setDesc(
      "Define a custom template to print the currently playing episode (Podcast only) or a path to your template definition"
    ).addTextArea(
      (text) => text.setPlaceholder(
        "Example: '{{ podcast_name }}': {{ description }} released {{ release_date }}\n{{ timestamp }}"
      ).setValue(this.plugin.settings.templates[1]).onChange(async (value) => {
        this.plugin.settings.templates[1] = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Default destination").setDesc(
      "Destination to store track or episode when using the command palette, default at the root of your vault"
    ).addText(
      (text) => text.setValue(this.plugin.settings.defaultDestination).onChange(async (value) => {
        this.plugin.settings.defaultDestination = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Allow overwrite").setDesc("Overwrite the file if it already exists in the vault.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.overwrite);
      toggle.onChange(async (value) => {
        this.plugin.settings.overwrite = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Auto Open").setDesc(
      "Automatically open the newly created file in the active leaf."
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.autoOpen);
      toggle.onChange(async (value) => {
        this.plugin.settings.autoOpen = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("hr");
    containerEl.createEl("h5", { text: "Spotify Integration (Advanced)" });
    new import_obsidian2.Setting(containerEl).setName("Spotify Scopes").setDesc(
      "Scopes (comma-delimited list, you should update this only if you know what you are doing."
    ).addText(
      (text) => text.setPlaceholder("Enter your Scopes").setValue(this.plugin.settings.spotifyScopes).onChange(async (value) => {
        this.plugin.settings.spotifyScopes = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("hr");
    containerEl.createEl("a", {
      href: "https://studiowebux.github.io/obsidian-plugins-docs/docs/category/plugin-spotify-link",
      text: "Official Plugin Documentation"
    });
  }
};

// src/ui.ts
var import_obsidian3 = require("obsidian");
async function handleEditor(editor, clientId, clientSecret) {
  try {
    const track = await getCurrentlyPlayingTrackAsString(
      clientId,
      clientSecret
    );
    if (editor) {
      editor.replaceSelection(
        `> ${track}
> ${new Date().toDateString()} - ${new Date().toLocaleTimeString()}

`
      );
    }
  } catch (e) {
    new import_obsidian3.Notice(e.message);
  }
}
async function handleTemplateEditor(editor, template, clientId, clientSecret) {
  try {
    const track = await getCurrentlyPlayingTrack(clientId, clientSecret);
    if (editor) {
      editor.replaceSelection(
        `${await processCurrentlyPlayingTrack(clientId, clientSecret, track, template)}

`
      );
    }
  } catch (e) {
    new import_obsidian3.Notice(e.message);
  }
}

// src/events.ts
async function onAutoLogin(clientId, clientSecret) {
  const profile = await getMe(clientId, clientSecret);
  return profile ? { success: true, spotifyUrl: profile.external_urls.spotify } : { success: false, spotifyUrl: "" };
}
function onLogin(clientId, state, scope) {
  window.open(generateLoginUrl(clientId, state, scope, REDIRECT_URI));
}

// src/default.ts
var DEFAULT_SETTINGS = {
  spotifyClientId: "",
  spotifyClientSecret: "",
  spotifyScopes: "user-read-currently-playing",
  spotifyState: "it-can-be-anything",
  templates: [
    "**Song Name:** {{ song_name }}\n**Song URL:** {{ song_link }}\n**Album Name:** {{ album }}\n**Album Release Date:** {{ album_release }}\n**Album URL:** {{ album_link }}\n**Cover:** {{ album_cover_medium }}\n**Cover URL:** {{ album_cover_link_medium }}\n**Artists:** {{ artists }}\n**Added at:** *{{ timestamp }}*",
    "**Episode Name:** {{ episode_name }}\n**Description:** {{ description }}\n**Added at:** *{{ timestamp }}*"
  ],
  menu: [
    {
      name: "Create file for currently playing episode using template",
      enabled: true,
      id: "create-file-for-currently-playing-episode-using-template"
    },
    {
      name: "Create file for currently playing episode",
      enabled: true,
      id: "create-file-for-currently-playing-episode"
    },
    {
      name: "Create file for currently playing track using template",
      enabled: true,
      id: "create-file-for-currently-playing-track-using-template"
    },
    {
      name: "Create file for currently playing track",
      enabled: true,
      id: "create-file-for-currently-playing-track"
    }
  ],
  defaultDestination: "",
  overwrite: false,
  autoOpen: false
};

// src/main.ts
var SpotifyLinkPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    // States
    this.spotifyConnected = false;
    this.spotifyUrl = "";
  }
  async loadOrGetTemplate(input) {
    try {
      if (!input)
        return "";
      const exists = await this.app.vault.adapter.exists(input, true);
      if (exists) {
        return this.app.vault.adapter.read(input);
      } else {
        const exists_with_md = await this.app.vault.adapter.exists(
          input + ".md",
          true
        );
        if (exists_with_md) {
          return this.app.vault.adapter.read(input + ".md");
        }
      }
      if (isPath(input)) {
        new import_obsidian4.Notice(
          "[WARN] Spotify Link Plugin: The provided template looks like a path, if so, the file hasn't been found.",
          1e4
        );
      }
      return input;
    } catch (e) {
      new import_obsidian4.Notice("[ERROR] Spotify Link Plugin: " + e.message, 1e4);
      return "";
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async autoOpen(filename) {
    if (this.settings.autoOpen === true) {
      try {
        await this.app.workspace.getLeaf().openFile(this.app.vault.getAbstractFileByPath(filename));
      } catch (e) {
        new import_obsidian4.Notice("[ERROR] Spotify Link Plugin: " + e.message, 1e4);
      }
    }
  }
  async createFolder(vault, folder) {
    try {
      await vault.createFolder(folder);
    } catch (e) {
      if (e.message !== "Folder already exists.") {
        new import_obsidian4.Notice("[ERROR] Spotify Link Plugin: " + e.message, 1e4);
      }
    }
  }
  async overwrite(filename, content, exists) {
    if (this.settings.overwrite === true) {
      try {
        await this.app.vault.modify(
          this.app.vault.getAbstractFileByPath(filename),
          content
        );
        if (exists) {
          new import_obsidian4.Notice("Spotify Link Plugin: track or episode overwritten.");
        }
      } catch (e) {
        new import_obsidian4.Notice("[ERROR] Spotify Link Plugin: " + e.message, 1e4);
      }
    }
  }
  async createFile(parent, id) {
    var _a, _b;
    let content = "";
    let track = null;
    let template_index = -1;
    if (id === "create-file-for-currently-playing-episode" || id === "create-file-for-currently-playing-track") {
      track = await getCurrentlyPlayingTrackAsString(
        this.settings.spotifyClientId,
        this.settings.spotifyClientSecret
      );
      content = `> ${track}
> ${new Date().toDateString()} - ${new Date().toLocaleTimeString()}

`;
    } else {
      track = await getCurrentlyPlayingTrack(
        this.settings.spotifyClientId,
        this.settings.spotifyClientSecret
      );
      if (id === "create-file-for-currently-playing-episode-using-template") {
        template_index = 1;
      } else if (id === "create-file-for-currently-playing-track-using-template") {
        template_index = 0;
      }
      content = `${await processCurrentlyPlayingTrack(
        this.settings.spotifyClientId,
        this.settings.spotifyClientSecret,
        track,
        await this.loadOrGetTemplate(this.settings.templates[template_index])
      )}

`;
    }
    const filename = `${(0, import_obsidian4.normalizePath)(
      `/${parent}/${(_b = (_a = track == null ? void 0 : track.item) == null ? void 0 : _a.name) != null ? _b : new Date().toISOString()}`
    ).replace(/[:|.]/g, "_")}.md`;
    const exists = await this.app.vault.adapter.exists(filename, true);
    const folder = filename.substring(0, filename.lastIndexOf("/"));
    try {
      await this.createFolder(this.app.vault, folder);
      await this.app.vault.create(filename, content);
      await this.autoOpen(filename);
    } catch (e) {
      await this.overwrite(filename, content, exists);
      await this.autoOpen(filename);
      new import_obsidian4.Notice("[ERROR] Spotify Link Plugin: " + e.message, 1e4);
    }
  }
  async onload() {
    var _a;
    await this.loadSettings();
    this.addSettingTab(new SettingsTab(this.app, this));
    (0, import_obsidian4.addIcon)(
      "spotify",
      '<path fill="currentColor" d="M 52.021502,2.019 C 24.520376,2.019 2.019,24.520376 2.019,52.021502 2.019,79.517624 24.520376,102.019 52.021502,102.019 79.517624,102.019 102.019,79.517624 102.019,52.021502 102.019,24.520376 79.767861,2.019 52.021502,2.019 Z m 22.996847,72.248636 c -0.995946,1.496422 -2.74761,2.001902 -4.254041,1.005956 -11.756168,-7.256894 -26.50518,-8.758321 -44.006806,-4.759522 -1.741655,0.510485 -3.243081,-0.740703 -3.743557,-2.247134 -0.50548,-1.751665 0.745709,-3.243081 2.25214,-3.748562 18.993043,-4.254041 35.498724,-2.497372 48.496071,5.50523 1.751664,0.745709 2.001902,2.742606 1.256193,4.244032 z m 6.005706,-13.74806 c -1.256194,1.746659 -3.503328,2.497372 -5.259997,1.246183 -13.497823,-8.237826 -33.992293,-10.750212 -49.742255,-5.745458 -1.991893,0.50548 -4.254042,-0.500475 -4.749512,-2.492368 -0.505481,-2.011911 0.500475,-4.26405 2.497372,-4.764526 18.247335,-5.49522 40.753716,-2.742605 56.248436,6.761424 1.501426,0.745708 2.25214,3.24308 1.005956,4.994745 z m 0.49547,-14.008308 C 65.519325,37.017248 38.768912,36.016297 23.514421,40.775819 a 4.6944597,4.6944597 0 0 1 -5.745459,-3.002853 4.689455,4.689455 0 0 1 2.997848,-5.760472 c 17.751865,-5.249988 47.004655,-4.254042 65.507232,6.761423 2.247135,1.246184 2.997848,4.249037 1.74666,6.496172 -1.251189,1.751664 -4.249037,2.492367 -6.501177,1.241179 z" style="stroke-width:5.00475" />'
    );
    this.addRibbonIcon("spotify", "Connect Spotify", () => {
      onLogin(
        this.settings.spotifyClientId,
        this.settings.spotifyState,
        this.settings.spotifyScopes
      );
    });
    this.statusBar = this.addStatusBarItem();
    this.registerInterval(
      window.setInterval(() => this.updateStatusBar(), 3e4)
    );
    this.registerObsidianProtocolHandler(
      "spotify-auth",
      async (params) => {
        try {
          this.spotifyConnected = await handleCallback(
            params,
            this.settings.spotifyClientId,
            this.settings.spotifyClientSecret,
            this.settings.spotifyState
          );
          new import_obsidian4.Notice("Spotify Link Plugin: Connected to Spotify !", 3e3);
          this.spotifyUrl = await getSpotifyUrl(
            this.settings.spotifyClientId,
            this.settings.spotifyClientSecret
          );
        } catch (e) {
          new import_obsidian4.Notice("[ERROR] Spotify Link Plugin: " + e.message, 3e3);
          this.spotifyConnected = false;
        } finally {
          this.updateStatusBar();
        }
      }
    );
    this.addCommand({
      id: "append-currently-playing-episode-using-template",
      name: "Append Spotify currently playing episode using template",
      editorCallback: async (editor) => {
        await handleTemplateEditor(
          editor,
          await this.loadOrGetTemplate(this.settings.templates[1]),
          this.settings.spotifyClientId,
          this.settings.spotifyClientSecret
        );
      }
    });
    this.addCommand({
      id: "append-currently-playing-episode",
      name: "Append Spotify currently playing episode with timestamp",
      editorCallback: async (editor) => {
        await handleEditor(
          editor,
          this.settings.spotifyClientId,
          this.settings.spotifyClientSecret
        );
      }
    });
    this.addCommand({
      id: "append-currently-playing-track-using-template",
      name: "Append Spotify currently playing track using template",
      editorCallback: async (editor) => {
        await handleTemplateEditor(
          editor,
          await this.loadOrGetTemplate(this.settings.templates[0]),
          this.settings.spotifyClientId,
          this.settings.spotifyClientSecret
        );
      }
    });
    this.addCommand({
      id: "append-currently-playing-track",
      name: "Append Spotify currently playing track with timestamp",
      editorCallback: async (editor) => {
        await handleEditor(
          editor,
          this.settings.spotifyClientId,
          this.settings.spotifyClientSecret
        );
      }
    });
    this.addCommand({
      id: "refresh-session",
      name: "Refresh session",
      callback: async () => {
        try {
          await requestRefreshToken(
            this.settings.spotifyClientId,
            this.settings.spotifyClientSecret
          );
          new import_obsidian4.Notice(`Spotify Link Plugin: Access Refreshed`);
        } catch (e) {
          new import_obsidian4.Notice(`[ERROR] Spotify Link Plugin: ${e.message}`);
        }
      }
    });
    this.addCommand({
      id: "create-file-for-currently-playing-episode-using-template",
      name: "Create file for currently playing episode using template",
      callback: async () => {
        var _a2;
        await this.createFile(
          (_a2 = this.settings.defaultDestination) != null ? _a2 : "",
          "create-file-for-currently-playing-episode-using-template"
        );
      }
    });
    this.addCommand({
      id: "create-file-for-currently-playing-episode",
      name: "Create file for currently playing episode",
      callback: async () => {
        var _a2;
        await this.createFile(
          (_a2 = this.settings.defaultDestination) != null ? _a2 : "",
          "create-file-for-currently-playing-episode"
        );
      }
    });
    this.addCommand({
      id: "create-file-for-currently-playing-track-using-template",
      name: "Create file for currently playing track using template",
      callback: async () => {
        var _a2;
        await this.createFile(
          (_a2 = this.settings.defaultDestination) != null ? _a2 : "",
          "create-file-for-currently-playing-track-using-template"
        );
      }
    });
    this.addCommand({
      id: "create-file-for-currently-playing-track",
      name: "Create file for currently playing track",
      callback: async () => {
        var _a2;
        await this.createFile(
          (_a2 = this.settings.defaultDestination) != null ? _a2 : "",
          "create-file-for-currently-playing-track"
        );
      }
    });
    if ((_a = this.settings) == null ? void 0 : _a.menu) {
      for (const customMenu of this.settings.menu) {
        if (!customMenu.enabled)
          return;
        const menuCreateFile = (menu, file) => {
          menu.addItem((item) => {
            item.setTitle(customMenu.name).onClick(async () => {
              try {
                await this.createFile(file.path, customMenu.id);
              } catch (e) {
                new import_obsidian4.Notice(`[ERROR] Spotify Link Plugin: ${e.message}`);
                return false;
              }
            });
          });
        };
        this.registerEvent(this.app.workspace.on("file-menu", menuCreateFile));
      }
    } else {
      new import_obsidian4.Notice("Your spotify link configuration might be outdated.");
    }
    try {
      const info = await onAutoLogin(
        this.settings.spotifyClientId,
        this.settings.spotifyClientSecret
      );
      this.spotifyConnected = info.success;
      this.spotifyUrl = info.spotifyUrl;
    } catch (e) {
      new import_obsidian4.Notice(`[ERROR] Spotify Link Plugin: ${e.message}`);
      return false;
    } finally {
      this.updateStatusBar();
    }
  }
  onunload() {
  }
  updateStatusBar() {
    this.statusBar.setText(
      `Spotify ${!this.spotifyConnected ? "not" : ""} Connected`
    );
  }
};

/* nosourcemap */